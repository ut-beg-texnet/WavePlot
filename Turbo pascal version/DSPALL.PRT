     TYPE
       ScaleTypes = (ScLinked, ScNotLinked, ScSet);

     VAR
       Qtyn, Startn      : Single;
       Vzoom             : Integer;
       Hzoom             : Single;
       MxQty, MxLegMax   : Single;
       GroupScale        : ScaleTypes;
       LogDiv, ScRound   : Integer;
       SameColour        : Boolean;


     PROCEDURE SetVscale (Sc : ScaleTypes);
       VAR
         i, MxQ  : Integer;
         Mx      : Single;
       BEGIN
         GroupScale := Sc;
         CASE GroupScale OF
            ScSet       : FOR i := 1 TO QtySeism DO
                            Seism[i].GR.LegMax := Sets.SLegMax[i];
            ScNotLinked : FOR i := 1 TO QtySeism DO
                            Seism[i].GR.LegMax := RoundPlaces (Seism[i].HstMap.Vmax,ScRound);
            ScLinked    : BEGIN
                            Mx  := 0;
                            MxQ := 0;
                            FOR i := 1 TO QtySeism DO
                              IF (Seism[i].HstMap.Tqty > MxQ)
                                 THEN MxQ := Seism[i].HstMap.Tqty;
                            FOR i := 1 TO QtySeism DO
                              IF (Seism[i].HstMap.Vmax > Mx)
                                 THEN Mx := Seism[i].HstMap.Vmax;
                            FOR i := 1 TO QtySeism DO
                              Seism[i].GR.LegMax := Mx;
                            MxQty    := MxQ;
                            MxLegMax := Mx;
                          END; {ScLinked}
         END; {Case}
       END; {SetVscale}

     PROCEDURE FixLegMax;
       VAR
         i : Integer;
       BEGIN
         FOR i := 1 TO QtySeism DO
           Sets.sLegMax[i] := RoundPlaces ( (Seism[i].GR.LegMax / Vzoom), 2);
         Vzoom := 1;
         SetVscale (ScSet);
       END; {FixLegMax}



     PROCEDURE Ds_CalcQtys;
       VAR
         i             : Integer;
         TmpQty, TmpSt : Integer;
       BEGIN
         CASE (GroupScale) OF
           ScLinked    : BEGIN
                           TmpQty := ROUND (MxQty * Qtyn);
                           TmpSt  := ROUND (MxQty * Startn);
                           FOR i := 1 TO QtySeism DO
                             WITH Seism[i] DO
                               BEGIN
                                 IF (TmpSt > HstMap.Tqty)
                                    THEN GR.St  := HstMap.Tqty
                                    ELSE GR.St  := TmpSt;
                                 IF (TmpQty > (HstMap.Tqty - GR.St) )
                                    THEN GR.Qty := HstMap.Tqty - GR.St
                                    ELSE GR.Qty := TmpQty;
                               END;
                         END;
           ScSet,
           ScNotLinked : FOR i := 1 TO QtySeism DO
                           WITH Seism[i] DO
                             BEGIN
                               GR.Qty := ROUND (HstMap.Tqty * Qtyn);
                               GR.St  := ROUND (HstMap.Tqty * Startn);
                             END;
         END; {Case}
       END; {Ds_CalcQtys}

     PROCEDURE Ds_InitSz;
       BEGIN
         Qtyn       := 1;
         Startn     := 0;
         Hzoom      := 1.5;
         Vzoom      := 1;
         LogDiv     := 4;
         ScRound    := 2;
         QtyWind    := QtySeism;
         SingleWind := False;
         SameColour := False;
         SetVscale (ScNotLinked);    {Individual Windows for Seismograms are not Linked}
         Ds_CalcQtys;
         Ds_CalcSeismWind;
       END; {Ds_InitSz}


     PROCEDURE Ds_ViewSeism (Choice : Char);
       VAR
         i : Integer;
       BEGIN
         WITH Seism[1].HstMap DO
           CASE Choice OF
             'Z'      : BEGIN
                          Qtyn := Qtyn / Hzoom;
                          IF (Qtyn < 0.05)
                             THEN Qtyn := 0.05;
                        END;
             'z'      : BEGIN
                          Qtyn := Qtyn * Hzoom;
                          IF (Qtyn > (1-Startn) )
                             THEN Qtyn := 1-Startn;
                        END;
             'X'      : Vzoom := ROUND (Vzoom * 1.6);
             'x'      : Vzoom := TRUNC (Vzoom * 0.4) + 1;
             'I'      : Hzoom := SQR (Hzoom);
             'i'      : Hzoom := SQRT(Hzoom);
             'K', 'k' : SameColour := NOT (SameColour);
             'F', 'f' : FixLegMax;
             'V', 'v' : CASE GroupScale OF
                          ScNotLinked : SetVScale (ScLinked);
                          ScLinked    : SetVScale (ScSet);
                          ScSet       : SetVScale (ScNotLinked);
                        END; {Case}
             'w', 'W' : IF (SingleWind)
                           THEN BEGIN
                                  SingleWind := False;
                                  QtyWind    := QtySeism;
                                  Ds_CalcSeismWind;
                                  SetVScale (ScNotLinked);
                                END
                           ELSE BEGIN
                                  SingleWind := True;
                                  QtyWind    := 1;
                                  Ds_CalcSeismWind;
                                  SetVScale (ScLinked);
                                END;
             'N', 'n' : Ds_InitSz;
             '>'      : IF (LogDiv < 10)
                           THEN Inc (LogDiv);
             '<'      : IF (LogDiv > 1)
                           THEN Dec (LogDiv);
             '+'      : IF (ScRound < 4)
                           THEN Inc (ScRound);
             '-'      : IF (ScRound > 1)
                           THEN Dec (ScRound);
             '0'..'9' : IF (Seism [Ival(Choice)].GR.ScalT = LinScal)
                           THEN Seism [Ival(Choice)].GR.ScalT := LogScal
                           ELSE Seism [Ival(Choice)].GR.ScalT := LinScal;
             #0       : CASE ReadKey OF
                          #71 {Home}  : Startn := 0;
                          #79 {End}   : Startn := (1 - Qtyn);
                          #75 {Left}  : BEGIN
                                          Startn := Startn - Qtyn/6;
                                          IF (Startn < 0)
                                             THEN Startn := 0;
                                        END;
                          #77 {Right} : BEGIN
                                          Startn := Startn + Qtyn/6;
                                          IF (Startn > (1 - Qtyn) )
                                             THEN Startn := (1 - Qtyn);
                                        END;
                        END; {Case}
           END; {Case}
         Ds_CalcQtys;
       END; {Ds_ViewSeism}


     PROCEDURE Ds_GetSeisms;
       VAR
         i,j  : Integer;
         Hmap : HistMapRec;
         GRs  : GRrec;
       {INCLUDE Parser}
         {$I Dsp\DspForm.Pas}
       BEGIN
         FOR i := 1 TO QtySeism DO
           WITH Seism[i] DO
             IF (FormSet)
                THEN BEGIN
                       {HstMap & GR definitions are Needed by Parse, but can't pass as a parameter to Parse - recursive}
                       Hmap := Seism[i].Hstmap;
                       GRs  := Seism[i].GR;
                       DI_ReadHist (Hnum, Hist);
                       Parse (Hist, Form);
                       Hmap.Vmax := 0;
                       FOR j := 1 TO Hmap.Tqty DO
                         Hmap.Vmax := Max (Hmap.Vmax, ABS(Hist^[j]) );
                       Hmap.HistVar    := 19; {Indicates a formula}
                       Seism[i].Hstmap := Hmap;
                       Seism[i].GR     := GRs;
                     END
                ELSE DI_ReadHist (Hnum, Hist);
       END; {Ds_GetSeisms}


     PROCEDURE Ds_SeismAxes;
       VAR
         i : Integer;
       BEGIN
         SetColor (DsCol_Axes);
         FOR i := 1 TO QtyWind DO
           BEGIN
             Ds_SetWindow (SeismWind[i,2]);
             WITH SeismWind[i,2] DO
               BEGIN
                 Line (0, 0, 0, Sz[2]-1);
                 CASE Seism[i].GR.ScalT OF
                   LinScal : Line (0, Sz[2] DIV 2, Sz[1]-1, Sz[2] DIV 2);
                   LogScal : Line (0, Sz[2]-1, Sz[1]-1, Sz[2]-1);
                 END; {Case}
               END;
           END; {For}
       END; {Ds_SeismAxes}


     PROCEDURE Ds_SeismLeg;
       VAR
         i          : Integer;
         LegScale   : Integer;
         LegNum     : Single;

       PROCEDURE LinLeg;
         BEGIN
           WITH Seism[i] DO
           WITH HstMap DO
             BEGIN
               Ds_SetWindow (SeismWind[i,1]);
               WITH SeismWind[i,1] DO
                 BEGIN
                   SetColor (DsCol_Val);
                   SetTextJustify (RightText, TopText);
                   OutTextXY (Sz[1]-1, 0,     '+' + Strng(LegNum,$0200) );
                   SetTextJustify (RightText, BottomText);
                   OutTextXY (Sz[1]-1, Sz[2]-1, '-' + Strng(LegNum,$0200) );
                   SetColor (DsCol_Scal);
                   SetTextStyle (SmallFont, HorizDir, FontSz-2);
                   SetTextJustify (RightText, TopText);
                   OutTextXY (Sz[1]-8, Sz[2] DIV 6, Strng(LegScale, $0000)  );
                   SetTextStyle (SmallFont, HorizDir, FontSz-1);
                   OutTextXY (Sz[1]-17, Sz[2] DIV 6, '  *10');
                 END;
             END; {With Seism[i]}
         END; {LinLeg}

       PROCEDURE LogLeg;
         VAR
           j, Stp : Integer;
         BEGIN
           WITH Seism[i] DO
           WITH HstMap DO
             BEGIN
               Ds_SetWindow (SeismWind[i,1]);
               WITH SeismWind[i,1] DO
                 BEGIN
                   {Vertical Axis Legends}
                   SetColor (DsCol_Val);
                   SetTextStyle (SmallFont, HorizDir, FontSz-2);
                   SetTextJustify (LeftText, TopText);
                   OutTextXY (0, 0, Strng(LegNum,$0200) );
                   OutTextXY (0, Sz[2] DIV 6, '10' + Strng(LegScale, $0000)  );

                   SetColor (DsCol_Scal);
                   Stp := (Sz[2]-1) DIV LogDiv;
                   SetTextJustify (RightText, TopText);
                   SetTextStyle (SmallFont, HorizDir, FontSz-2);
                   FOR j := 0 TO (LogDiv-1) DO
                     OutTextXY (Sz[1]-7, j*Stp, Strng(-j,$0000) );
                   SetTextStyle (SmallFont, HorizDir, FontSz-1);
                   OutTextXY (Sz[1]-12, 0, '10');
                   FOR j := 1 TO (LogDiv-1) DO
                     OutTextXY (Sz[1]-17, j*Stp, '10');
                   FOR j := 0 TO (LogDiv-1) DO
                     Line (Sz[1]-5, j*Stp, Sz[1]-1, j*Stp);
                 END;
             END; {With Seism[i]}
         END; {LogLeg}

       BEGIN {Ds_SeismLeg}
         SetTextStyle (SmallFont, HorizDir, FontSz-1);
         FOR i := 1 TO QtyWind DO
           WITH Seism[i] DO
           WITH HstMap DO
             BEGIN
               {Horizontal Axis Legends}
               SetColor (DsCol_Val);
               Ds_SetWindow (SeismWind[i,1]);
               SetTextJustify (RightText, BottomText);
               WITH SeismWind[i,1] DO
                 OutTextXY (Sz[1]-1, GR.Ds_Voff, GR.xchar + '=' + Strng( (GR.St*Dt),$0200) );
               Ds_SetWindow (SeismWind[i,3]);
               SetTextJustify (LeftText, BottomText);
               WITH SeismWind[i,3] DO
                 BEGIN
                   OutTextXY (0, GR.Ds_Voff, ' ' + GR.xchar + '=' + Strng( ((GR.St+GR.Qty)*Dt),$0200) );
                   OutTextXY (0, GR.Ds_Voff - Sz[2] DIV 6, ' ' + 'n'  + '=' + Strng( (GR.St+GR.Qty),$0200) );
                   SetTextJustify (LeftText, TopText);
                   IF (SameColour)
                      THEN SetColor (DsCol_Seism)
                      ELSE SetColor (i);
                   IF NOT (SingleWind)
                      THEN OutTextXY (0, 0, ' ' + VarName[HistVar]);
                 END;
               LegNum   := GR.LegMax / Vzoom;
               LegScale := TRUNC (LN(LegNum) / Ln10) - 1;
{               LegScale := LegScale - (LegScale MOD 3);}
               LegNum   := LegNum / EXP(LegScale*Ln10);
               CASE Seism[i].GR.ScalT OF
                 LinScal : LinLeg;
                 LogScal : LogLeg;
               END; {Case}
             END; {With GR & HstMap}
         Ds_SetWindow (SeismWind[1,3]);
         SetTextJustify (LeftText, TopText);
         SetColor (DsCol_Seism);
         IF (SingleWind)
            THEN FOR i := 1 TO QtySeism DO
                   BEGIN
                     IF NOT (SameColour)
                        THEN SetColor (i);
                     OutTextXY (0, i*12, ' ' + VarName[Seism[i].HstMap.HistVar]);
                   END;
       END; {Ds_SeismLeg}


     PROCEDURE Ds_DrawSeism;
       VAR
         i  : Integer;

       PROCEDURE DrawLinear;
         VAR
           Hscale, Vscale : Single;
           h,Stp          : Integer;
         BEGIN
           WITH Seism[i] DO
             WITH SeismWind[i,2] DO
               BEGIN
                 Vscale  := -Sz[2]/2 / 1.05 / (GR.LegMax / Vzoom);
                 GR.Ds_Voff :=  Sz[2] DIV 2;
                 IF (GroupScale = ScLinked)
                    THEN Hscale :=  Sz[1]   / MxQty / Qtyn
                    ELSE Hscale :=  Sz[1]   / GR.Qty;
               END;
           Ds_SetWindow (SeismWind[i,2]);
           WITH Seism[i] DO
             BEGIN
               IF (GR.St = 0)
                  THEN MoveTo ( 0, GR.Ds_Voff)
                  ELSE MoveTo ( 0, ROUND (Hist^[GR.St]*Vscale) + GR.Ds_Voff);
               Stp := TRUNC (1 / Hscale);
               IF (Stp = 0)
                  THEN Stp := 1;
               h := 1;
               REPEAT
                 LineTo ( ROUND ((h)*Hscale), ROUND (Hist^[h+GR.St]*Vscale) + GR.Ds_Voff);
                 h := h + Stp;
               UNTIL (h > GR.Qty);
             END;
         END; {DrawLinear}

       PROCEDURE DrawLog;
         VAR
           h, Stp        : Integer;
           Hscale, Vscale,
              LnMax, Vpt, Mult : Single;

         FUNCTION LnScale (Yval : Single) : Single;
           VAR
             LnVal : Single;
           BEGIN
             IF (Yval = 0)
                THEN LnVal := 0
                ELSE BEGIN
                       LnVal := 1 - Mult * (LnMax - LN (ABS(Yval)) );
                       IF (LnVal < 0) THEN LnVal := 0;
                     END;
             LnScale := LnVal;
           END; {LnScale}

         BEGIN {DrawLog}
           WITH Seism[i] DO
             WITH SeismWind[i,2] DO
               BEGIN
                 LnMax   :=  LN(GR.LegMax / Vzoom);
                 Mult    :=  1 / (LogDiv * Ln10);
                 Vscale  := -Sz[2] / 1.05;
                 GR.Ds_Voff :=  TRUNC ((Sz[2]-1) / 1.0);
                 IF (GroupScale = ScLinked)
                    THEN Hscale :=  Sz[1]   / MxQty / Qtyn
                    ELSE Hscale :=  Sz[1]   / GR.Qty;
                 Stp := TRUNC (1 / Hscale);
                 IF (Stp = 0)
                    THEN Stp := 1;
               END;
           Ds_SetWindow (SeismWind[i,2]);
           WITH Seism[i] DO
             BEGIN
               IF (GR.St = 0)
                  THEN Vpt := 0
                  ELSE Vpt := LnScale (Hist^[GR.St]);
               MoveTo ( 0, ROUND (Vpt*Vscale) + GR.Ds_Voff);
               h := 1;
               REPEAT
                 Vpt := LnScale (Hist^[h+GR.St]);
                 LineTo ( ROUND ((h)*Hscale), ROUND (Vpt*Vscale) + GR.Ds_Voff);
                 h := h + Stp;
               UNTIL (h > GR.Qty);
             END;
         END; {DrawLog}

       BEGIN {Ds_DrawSeism}
         SetColor (DsCol_Seism);
         FOR i := 1 TO QtySeism DO
           BEGIN
             IF NOT (SameColour)
                THEN SetColor (i);
             CASE Seism[i].GR.ScalT OF
               LinScal : DrawLinear;
               LogScal : DrawLog;
             END; {Case}
           END;
       END; {Ds_DrawSeism}


     PROCEDURE Ds_ListSeisms;
       VAR
         i, Divs : Word;
       BEGIN
         Ds_SetWindow (LegWind);
         ClearViewPort;
         SetColor (DsCol_List);
         SetTextStyle (SmallFont, HorizDir, FontSz-1);
         SetTextJustify (LeftText, CenterText);
         Divs := 2*QtySeism + 6;
         IF (Divs < 20)
            THEN Divs := 20;

         WITH Seism[1].HstMap DO
           BEGIN
             MoveTo ( Hinset, TRUNC (1/Divs * LegWind.Sz[2]) );
             OutText ('T-st: ' + Strng (Tstart,$0300) + ' T-end: ' + Strng (Time,$0300) );
             MoveTo ( Hinset, TRUNC (2/Divs * LegWind.Sz[2]) );
             OutText ('Time Interval: ' + Strng (dt, $0300) );
           END; {With}

{         SetColor (DsCol_Seism);}
         FOR i := 1 TO QtySeism DO
           BEGIN
             MoveTo ( Hinset, TRUNC ( (2+2*i)/Divs * LegWind.Sz[2]) );
             IF NOT (SameColour)
                THEN SetColor (i);
             WITH Seism[i].HstMap DO
               OutText ('['  + Strng (i,$0100) + ']' +
                       ' X=' + Strng (Xp, $0100) + ' Y=' + Strng (Yp, $0100) + ' Z=' + Strng (Zp, $0100) );
             MoveTo ( Hinset, TRUNC ( (3+2*i)/Divs * LegWind.Sz[2]) );
             WITH Seism[i] DO
               IF (FormSet)
                  THEN OutText ('  F(t) = ' + Form);
           END; {For}

         ResetViewPort;
       END; {Ds_ListSeisms}


   {Messages and User Interface}

     PROCEDURE Ds_WaitMessage (S : String;  VAR Ch : Char);
       CONST
         Sentence = 19;
       VAR
         S2    : String[30];
         Lines : Word;
         Count : Word;
       BEGIN
         SetTextStyle (SmallFont, HorizDir, FontSz);
         SetColor (Yellow);
         Ds_DrawWindow (MsgWind);
         ClearViewPort;
         Lines := Length(S) DIV Sentence + 2;
         IF (Lines < 6)
            THEN Lines := 6;
         Count := 1;
         SetColor (Yellow);
         SetTextJustify (LeftText, CenterText);
         WHILE (Length(S) > Sentence) DO
           BEGIN
             S2 := Copy (s, 1, Sentence);
             Delete (s, 1, Sentence);
             MoveTo ( Hinset, TRUNC (Vscale/4 * (Count/Lines) )  );
             OutText (S2);
             Inc (Count);
           END;
         MoveTo ( Hinset, TRUNC (Vscale/4 * (Count/Lines) )  );
         OutText (s);
         Ch := ReadKey;
         ClearViewPort;
         ResetViewPort;
       END; {Ds_WaitMessage}


     PROCEDURE Ds_SendMessage (S : String);
       CONST
         Sentence = 19;
       VAR
         S2    : String[30];
         Lines : Word;
         Count : Word;
       BEGIN
         SetTextStyle (SmallFont, HorizDir, FontSz);
         Ds_SetWindow (MsgWind);
         ClearViewPort;
         Lines := Length(S) DIV Sentence + 2;
         IF (Lines < 6)
            THEN Lines := 6;
         Count := 1;
         SetColor (Yellow);
         SetTextJustify (LeftText, CenterText);
         WHILE (Length(S) > Sentence) DO
           BEGIN
             S2 := Copy (s, 1, Sentence);
             Delete (s, 1, Sentence);
             MoveTo ( Hinset, TRUNC (Vscale/4 * (Count/Lines) )  );
             OutText (S2);
             Inc (Count);
           END;
         MoveTo ( Hinset, TRUNC (Vscale/4 * (Count/Lines) )  );
         OutText (s);
         ResetViewPort;
       END; {Ds_SendMessage}


     PROCEDURE Ds_AddMessage (Snum, Sqty : Word; S : String);
       BEGIN
         SetTextStyle (SmallFont, HorizDir, FontSz);
         SetColor (Yellow);
         SetTextJustify (LeftText, CenterText);
         Ds_SetWindow (MsgWind);
         MoveTo ( Hinset, TRUNC (MsgWind.Sz[2] * Snum/(Sqty+1) )  );
         OutText (s);
         ResetViewPort;
       END; {Ds_AddMessage}


     PROCEDURE Ds_WaitResponse (VAR Ch : Char);
       BEGIN
         Ds_SetWindow (MsgWind);
         Ch := ReadKey;
         ClearViewPort;
         ResetViewPort;
       END; {Ds_AddMessage}

   {Display Primitives}
   {Scaling Routines}

     PROCEDURE Ds_GetBlockSz (Xqty, Yqty : Integer;
                                    VAR  Sz : Pixels );
       BEGIN
         IF (Xqty > Yqty)
            THEN BEGIN
                   Sz[2] := (Vscale+1) DIV Xqty;
                   Sz[1] := (Hscale+1) DIV Xqty;
                 END
            ELSE BEGIN
                   Sz[2] := (Vscale+1) DIV Yqty;
                   Sz[1] := (Hscale+1) DIV Yqty;
                 END;
       END; {Ds_GetBlockSz}


     PROCEDURE Ds_CalcScale (Xqty, Yqty : Integer);
       BEGIN
         IF (Hpix/Xqty > Vpix/Aspect/Yqty)
            THEN BEGIN
                   Ds_Pscale[y] := Vpix / Yqty;
                   Ds_Pscale[x] := Vpix/Aspect/Yqty;
                 END
            ELSE BEGIN
                   Ds_Pscale[x] := Hpix / Xqty;
                   Ds_Pscale[y] := Hpix*Aspect/Xqty;
                 END;
       END; {Ds_CalcScale}

       PROCEDURE TestPalette;
         VAR
           Ch : Char;
           ix, iy : Word;
         BEGIN
           Ds_SetWindow (LegWind);
           FOR iy := 0 TO 15 DO
             FOR ix := 0 TO 15 DO
               BEGIN
                 SetFillStyle (SolidFill, iy*16+ix);
                 Bar (ix*9+2, iy*9+2, (ix+1)*9, (iy+1)*9);
               END;
           Ch := ReadKey;
           ClearViewPort;
           ResetViewPort;
         END; {TestPalette}

       PROCEDURE TestPalette2;
         VAR
           Ch : Char;
           ix, iy : Word;
         BEGIN
           Ds_SetWindow (LegWind);
           FOR iy := 0 TO (Sets.QtyCols DIV 6) DO
             FOR ix := 0 TO 5 DO
               BEGIN
                 SetFillStyle (SolidFill, ColOffset+iy*6+ix);
                 Bar (ix*10+2, iy*10+2, (ix+1)*10, (iy+1)*10);
               END;
           Ch := ReadKey;
           ClearViewPort;
           ResetViewPort;
         END; {TestPalette2}

     PROCEDURE Ds_Info (S : String; Col: Word; SNum: Word);
       VAR
         W     : ARRAY [1..2] OF Pixels;
         Vdiff : Integer;
         ColBak: Word;
       BEGIN
         SetTextStyle (SmallFont, HorizDir, FontSz);
         W[1,1] := Hscale DIV 8;
         W[1,2] := Vscale DIV 2 - 30 - Vscale DIV 5;
         W[2,1] := Hscale - W[1,1] - 50;
         W[2,2] := Vscale DIV 2 - 30 + Vscale DIV 5;
         Vdiff  := W[2,2] - W[1,2];
         IF (GraphDriver IN [HercMono, EGA])
            THEN SetActivePage ( (CurGraphPg + 1) MOD 2);
         ColBak := GetColor;
         SetColor  (Col);
         Rectangle   (W[1,1], W[1,2], W[2,1], W[2,2]);
         SetViewPort (W[1,1], W[1,2], W[2,1], W[2,2], ClipOn);
         IF (SNum = 2)
            THEN ClearViewPort;
         SetTextJustify (LeftText, CenterText);
         MoveTo ( 10, Vdiff DIV 10 * SNum + 4);
         OutText (s);
         ResetViewPort;
         IF (GraphDriver IN [HercMono, EGA])
            THEN SetActivePage (CurGraphPg);
         SetColor (ColBak);
       END; {Ds_Info}

    {WINDOWS}

       TYPE
         Ds_Window   = RECORD
                            St, Fin, Sz : Pixels; {Start & Finish Pixel co-ordinates & Size}
                          END;

       VAR
         SeismWind          : ARRAY [1..MaxSeism] OF
                                ARRAY [1..3]  OF Ds_Window;
         SnapWind, MsgWind,
                   LegWind  : Ds_Window;
         QtySeism, QtyWind  : Word;
         SingleWind         : Boolean;


       PROCEDURE ResetViewPort;
         BEGIN
           SetViewPort (0,0,Hpix-1, Vpix-1, ClipOn);
         END; {ResetViewPort}

       PROCEDURE Ds_SetWindow (w: Ds_Window);
         BEGIN
           WITH w DO
             SetViewPort (St[1], St[2], Fin[1], Fin[2], ClipOn);
         END; {Ds_SetWindow}

       PROCEDURE Ds_ClearWindow (w: Ds_Window);
         BEGIN
           WITH w DO
             SetViewPort (St[1], St[2], Fin[1], Fin[2], ClipOn);
           ClearViewPort;
           SetViewPort (0,0,Hpix-1, Vpix-1, ClipOn);
         END; {Ds_SetWindow}

       PROCEDURE Ds_DrawWindow (w: Ds_Window);
         BEGIN
           ResetViewPort;
           WITH w DO
             RECTANGLE (St[1]-1, St[2]-1, Fin[1]+1, Fin[2]+1);
           Ds_SetWindow (w);
         END; {Ds_DrawWindow}


       PROCEDURE Ds_InitWindows;
         BEGIN
           WITH SnapWind DO
             BEGIN
               St[1]  := 1;
               St[2]  := 1;
               Sz[1]  := TRUNC ( (Vpix-2) / Aspect);
               Sz[2]  := Vpix-2-St[2]+1;
               Fin[1] := St[1] + Sz[1] - 1;
               Fin[2] := Vpix - 2;
             END; {With SnapWind}
           WITH MsgWind DO
             BEGIN
               St[1]  := SnapWind.Fin[1]+10;
               St[2]  := 1;
               Sz[1]  := Hpix-2-St[1]+1;
               Sz[2]  := Vpix DIV 4;
               Fin[1] := Hpix-2;
               Fin[2] := St[2] + Sz[2] - 1;
             END; {With MsgWind}
           WITH LegWind DO
             BEGIN
               St[1]  := MsgWind.St[1];
               St[2]  := MsgWind.Fin[2] + 2;
               Sz[1]  := Hpix-2-St[1]+1;
               Sz[2]  := Vpix-2-St[2]+1;
               Fin[1] := Hpix-2;
               Fin[2] := Vpix-2;
             END; {With LegWind}
         END;  {Ds_InitWindows}


       PROCEDURE Ds_CalcSeismWind;
         CONST
           HzRat : ARRAY [1..6] OF Real = (0.0, 0.09, 0.1, 0.9, 0.91, 1.0);
           VtRat : ARRAY [1..2] OF Real = (0.1, 0.9);
         VAR
           i,j   : Word;
           Hz    : ARRAY [1..6] OF Word;
           Vt    : ARRAY [1..2] OF Word;
           VSize : Real;
         BEGIN
           Ds_ClearWindow (SnapWind);
           WITH SnapWind DO
             BEGIN
               FOR i := 1 TO 6 DO
                 Hz[i] := St[1] + TRUNC (Sz[1]*HzRat[i]);
               VSize := Sz[2] / QtyWind;
             END; {With}
           FOR i := 1 TO QtyWind DO
             BEGIN
               Vt[1] := TRUNC ( (i-1)*Vsize + VtRat[1]*Vsize);
               Vt[2] := TRUNC ( (i-1)*Vsize + VtRat[2]*Vsize);
               FOR j := 1 TO 3 DO
                 WITH SeismWind[i,j] DO
                   BEGIN
                     St[1]  := Hz[j*2-1];
                     Fin[1] := Hz[j*2];
                     St[2]  := Vt[1];
                     Fin[2] := Vt[2];
                     Sz[1]  := Fin[1] - St[1] + 1;
                     Sz[2]  := Fin[2] - St[2] + 1;
                   END; {With}
             END; {For}
           IF (SingleWind)
              THEN FOR i := 2 TO QtySeism DO
                     SeismWind[i] := SeismWind[1];
           SetColor (DsCol_Axes);
           Ds_DrawWindow (MsgWind);
           Ds_DrawWindow (LegWind);
         END;  {Ds_CalcSeismWind}


       PROCEDURE Ds_ClearSeism;
         VAR
           i,j   : Word;
         BEGIN
           FOR i := 1 TO QtySeism DO
             FOR j := 1 TO 3 DO
               Ds_ClearWindow (SeismWind[i,j]);
         END;  {Ds_ClearSeism}
   {Routines for Image storage, compression and retrieval}

     PROCEDURE Ds_SaveImage (SaveString : String);
       CONST
         Onebyte = 1;
         QtyBlks = 4;
       TYPE
         ImageBuf  = ARRAY [1..$8000] OF Byte;
       VAR
         Sz        : Word;
         Buffer    : ^ImageBuf;
         CrunchSz  : Word;
         Crunch    : ^ImageBuf;
         Hqty      : Word;
         ImageFile : File;
         i         : Word;

       PROCEDURE Ds_Crunch (VAR CrunchSz : Word);
         CONST
           MaxCt= 240;
           Ext1 = 245;
           Ext2 = 253;
         VAR
           i, j, Count, Ch : LongInt;
         BEGIN
           j := 0;
           Ch := Buffer^[1];
           Count := 1;
           FOR i := 1 TO Sz DO
             IF ( (Buffer^[i+1] = Ch) AND (Count < MaxCt) AND (i<Sz) )
                THEN Inc (Count)
                ELSE
                  IF ( (Count <= 3) AND  (Ch <> Ext1) AND (Ch <> Ext2) )
                     THEN BEGIN
                            REPEAT
                              Inc (j);
                              Crunch^ [j] := Ch;
                              Dec (Count);
                            UNTIL (Count = 0);
                            Ch := Buffer^[i+1];
                            Count := 1;
                          END
                     ELSE
                       BEGIN
                         IF ( (Ch = Ext1) OR (Ch = Ext2) )
                            THEN BEGIN Inc(j); Crunch^[j] := Ext1; END;
                         Inc (j);
                         Crunch^[j] := Ch;
                         Inc(j);
                         Crunch^[j] := Ext2;
                         Inc(j);
                         Crunch^[j] := Count;
                         Ch := Buffer^[i+1];
                         Count := 1;
                       END;
           CrunchSz := j;
         END; {Ds_Crunch}

       BEGIN {Ds_SaveImage}
         ResetViewPort;
         ASSIGN  (ImageFile, (Sets.Drive + ':' + Sets.Dir + '\' + Sets.Fname + '.I' + SaveString) );
         REWRITE (ImageFile, OneByte);
         New (Crunch);

         Hqty := (Hpix + QtyBlks - 1) DIV QtyBlks;
         Sz := ImageSize (0,0,Hqty-1,Vpix-1);
         GetMem (Buffer, Sz);

         FOR i := 1 TO (QtyBlks-1) DO
           BEGIN
             GetImage ((i-1)*Hqty, 0, i*Hqty-1, Vpix-1, Buffer^);
             Ds_Crunch (CrunchSz);
             BlockWrite (ImageFile, CrunchSz, 2);
             BlockWrite (ImageFile, Crunch^, CrunchSz);
           END;

         FreeMem (Buffer, Sz);
         Sz := ImageSize ((QtyBlks-1)*Hqty, 0, Hpix-1, Vpix-1);
         GetMem (Buffer, Sz);
         GetImage ((QtyBlks-1)*Hqty, 0, Hpix-1, Vpix-1, Buffer^);
         Ds_Crunch (CrunchSz);
         BlockWrite (ImageFile, CrunchSz, 2);
         BlockWrite (ImageFile, Crunch^, CrunchSz);
         FreeMem (Buffer, Sz);

         Dispose (Crunch);
         CLOSE (ImageFile);
       END; {Ds_SaveImage}

     PROCEDURE Ds_RestoreImage (SaveString : String);
       CONST
         Onebyte = 1;
         QtyBlks = 4;
       TYPE
         ImageBuf  = ARRAY [1..$8000] OF Byte;
       VAR
         Sz        : ARRAY [1..QtyBlks] OF Word;
         Buffer    : ARRAY [1..QtyBlks] OF ^ImageBuf;
         CrunchSz  : Word;
         Crunch    : ^ImageBuf;
         Hqty      : Word;
         ImageFile : File;
         i         : Word;

       PROCEDURE Ds_Expand (Bf: Word);
         CONST
           MaxCt= 240;
           Ext1 = 245;
           Ext2 = 253;
         VAR
           i, j, Count, Ch : LongInt;
         BEGIN
           i := 0;
           j := 1;
           REPEAT
             IF (Crunch^[j] = Ext1)
                THEN Inc (j);
             Ch := Crunch^[j];
             Inc (j);
             IF ( (Crunch^[j] <> Ext2) OR (j > CrunchSz) )
                THEN BEGIN
                       Inc (i);
                       Buffer[Bf]^[i] := Ch;
                     END
                ELSE BEGIN
                       FOR Count := 1 TO Crunch^[j+1] DO
                         BEGIN
                           Inc (i);
                           Buffer[Bf]^[i] := Ch;
                         END;
                       j := j + 2;
                     END;
           UNTIL (j > CrunchSz);
         END; {Ds_Expand}

       BEGIN {Ds_RestoreImage}
         ResetViewPort;
         ASSIGN  (ImageFile, (Sets.Drive + ':' + Sets.Dir + '\' + Sets.Fname + '.I' + SaveString) );
         {$I-}
         RESET   (ImageFile, OneByte);
         {$I+}
         IF (IOResult = 0)
            THEN BEGIN
                   IF (GraphDriver IN [HercMono, EGA])
                      THEN BEGIN
                             CurGraphPg := (CurGraphPg + 1) MOD 2;
                             SetActivePage (CurGraphPg);
                           END;

                   New (Crunch);
                   Hqty := (Hpix + QtyBlks - 1) DIV QtyBlks;

                   FOR i := 1 TO (QtyBlks-1) DO
                     BEGIN
                       Sz[i] := ImageSize (0,0,Hqty-1,Vpix-1);
                       GetMem (Buffer[i], Sz[i]);
                       BlockRead (ImageFile, CrunchSz, 2);
                       BlockRead (ImageFile, Crunch^, CrunchSz);
                       Ds_Expand (i);
                     END;

                   Sz[QtyBlks] := ImageSize ( (QtyBlks-1)*Hqty, 0, Hpix-1, Vpix-1);
                   GetMem (Buffer[QtyBlks], Sz[QtyBlks]);
                   BlockRead (ImageFile, CrunchSz, 2);
                   BlockRead (ImageFile, Crunch^, CrunchSz);
                   Ds_Expand(QtyBlks);

                   Dispose (Crunch);
                   CLOSE (ImageFile);
                   FOR i := 1 TO (QtyBlks) DO
                     BEGIN
                       IF (i=1)
                          THEN PutImage ( (i-1)*Hqty, 0, Buffer[i]^, NormalPut)
                          ELSE PutImage ( (i-1)*Hqty-1, 0, Buffer[i]^, NormalPut);
                       FreeMem (Buffer[i], Sz[i]);
                     END;
                   IF (GraphDriver IN [HercMono, EGA])
                      THEN SetVisualPage (CurGraphPg);
                 END;
       END; {Ds_RestoreImage}

     PROCEDURE Parse (Hst : HistPtr;  Pstring : String);
         {Hmap:HstMapRec & GRs:GRrec are assumed to exist externally.
                            Not passed as parameters due to recursion}
       CONST
         MaxParams = 3;
       VAR
         ParamCount : Integer;
         Params     : ARRAY [1..MaxParams] OF Real;

       PROCEDURE ParseBrackets;
         VAR
           Count, Pos : Word;
         BEGIN
           Count := 1;
           Pos   := 1;
           REPEAT
             Inc (Pos);
             IF (Pstring[Pos] = '(' )
                THEN Inc (Count);
             IF (Pstring[Pos] = ')' )
                THEN Dec (Count);
           UNTIL (Count = 0);
           Parse ( Hst, Copy (Pstring, 2, (Pos-2) )  );
           Delete (Pstring, 1, Pos);
         END; {ParseBrackets}

       PROCEDURE ParseParam;
         VAR
           Pos, Err, Hnum  : Word;
         BEGIN
           WHILE ( (Pstring<>'') AND (Pstring[1] = ',') ) DO
             BEGIN
               Inc (ParamCount);
               Pos   := 2;
               WHILE Pstring [Pos] IN ['0'..'9','.'] DO
                 Inc (Pos);
               Val ( Copy(Pstring,2,(Pos-2)), Params[ParamCount], Err);
               Delete (Pstring, 1, Pos-1);
             END;
         END; {ParseParams}


       PROCEDURE ParseHnum;
         VAR
           Pos, Err, Hnum  : Word;
         BEGIN
           Pos   := 2;
           WHILE Pstring [Pos] IN ['0'..'9'] DO
             Inc (Pos);
           Val ( Copy(Pstring,2,(Pos-2)), Hnum, Err);
           DI_ReadHist ( Hnum, Hst);
           Delete (Pstring, 1, Pos);
         END; {ParseHnum}

       PROCEDURE Integrate;
         VAR
           t            : Word;
           Prev1, Prev2 : Single;
         BEGIN
           Prev2   := Hst^[1];
           Hst^[1] := Hst^[1] / 2 * Hmap.Dt;
           FOR t := 2 TO Hmap.Tqty  DO
             BEGIN
               Prev1   := Hst^[t];
               Hst^[t] := Hst^[t-1] + (Prev1 + Prev2) / 2 * Hmap.Dt;
               Prev2   := Prev1;
             END;
         END; {Integrate}

       PROCEDURE Differentiate;
         VAR
           t            : Word;
           Prev1, Prev2 : Single;
         BEGIN
           Prev2   := Hst^[1];
           Hst^[1] := Hst^[1] * 2 / Hmap.Dt;
           FOR t := 2 TO Hmap.Tqty  DO
             BEGIN
               Prev1   := Hst^[t];
               Hst^[t] := 2 * (Prev1 - Prev2) / Hmap.Dt - Hst^[t-1];
               Prev2   := Prev1;
             END;
         END; {Differentiate}

       PROCEDURE Fourier (Inverse : Boolean;  Filt : F_Filt;  Repr : F_Repr);
         VAR
           N,i,st   : Integer;
           LowFreq,
           HighFreq : Single;
           Four     : FourArray;
         BEGIN
           IF (ParamCount >= 1)
              THEN LowFreq := Params[1] / 100
              ELSE LowFreq := Sets.LowFreq / 100;
           IF (ParamCount >= 2)
              THEN HighFreq := Params[2] / 100
              ELSE HighFreq := Sets.HighFreq / 100;

           WITH Hmap DO
             BEGIN
               N := TRUNC (Ln(Tqty-1) / Ln(2)) + 1 + Sets.FreqWind;
               N := ROUND ( EXP(N*Ln(2)) );
               IF (N > F_MaxEl)
                  THEN N := F_MaxEl;
               st  := (N - Tqty) DIV 2;
               {Zero Padding, No Taper}
               FOR i := 0 TO N-1 DO
                 Four[i] := Compl0;
               FOR i := 1 TO Tqty DO
                 Four[st+i].Rl := Hst^[i];
               FFT (Four, N, F_Trform);
               IF (Filt <> F_NoFilt)
                  THEN F_Filter (Four, Filt, N, TRUNC (N*LowFreq), TRUNC (N*HighFreq) );

               IF (Inverse)
                  THEN BEGIN
                         FFT (Four, N, F_Inverse);
                         Tqty := N;
                         FOR i := 1 TO Tqty DO
                           Hst^[i] := Four[i-1].Rl;
                       END
                  ELSE BEGIN
                         Tqty := N DIV 2;
                         dT := 1 / dT / N;
                         GRs.xchar := 'f';
                         CASE Repr OF
                           F_ampl  :  BEGIN
                                        FOR i := 1 TO Tqty DO
                                          Hst^[i] := SQRT ( SQR(Four[i-1].Rl) + SQR(Four[i-1].Im) );
                                        {Hst^[i] := Four[i-1].Rl;}
                                        GRs.ScalT := LogScal;
                                      END;
                           F_phase : FOR i := 1 TO Tqty DO
                                       Hst^[i] := Arctan0 (Four[i-1].Im, Four[i-1].Rl);
                         END; {Case}
                    END; {If direct transform}
             END; {With Hmap}
         END; {Fourier}

       PROCEDURE Func1 (f: Char);
         VAR
           Prev1, Prev2 : Single;
           t            : Integer;
         BEGIN
           Delete (Pstring, 1, 1);
           ParamCount := 0;
           IF (Pstring[1] = ',')
              THEN ParseParam;
           IF (Pstring [1] = '(')
              THEN ParseBrackets;
           CASE f OF
             'I', 'i' : BEGIN
                          Hst^[1] := Hst^[1] * Hmap.Dt;
                          FOR t := 2 TO Hmap.Tqty  DO
                            Hst^[t] := Hst^[t-1] + Hst^[t] * Hmap.Dt;
                        END;
             'D', 'd' : BEGIN
                          Prev2 := Hst^[1];
                          Hst^[1] := Hst^[1] / Hmap.Dt;
                          FOR t := 2 TO Hmap.Tqty  DO
                            BEGIN
                              Prev1 := Hst^[t];
                              Hst^[t] := (Hst^[t] - Prev2) / Hmap.Dt;
                              Prev2 := Prev1;
                            END;
                        END;
             'P'      : Fourier (F_Trform,  F_NoFilt,   F_phase);  {Fourier T'form - phase spectrum}
             'p'      : Fourier (F_Trform,  F_StepFilt, F_phase);  {Fourier T'form - phase spectrum, filtered}
             'F'      : Fourier (F_Trform,  F_NoFilt,   F_ampl);   {Fourier T'form - amplitude spectrum}
             'f'      : Fourier (F_Trform,  F_StepFilt, F_ampl);   {Fourier T'form - amplitude spectrum, filtered}
             'T'      : Fourier (F_Inverse, F_NoFilt,   F_ampl);   {Inverse F. T'form, of Fourier T'form, as test.}
             't'      : Fourier (F_Inverse, F_StepFilt, F_ampl);   {Inverse F. T'form, of Filtered Fourier Transform, as test}
           END; {Case}
         END;

       PROCEDURE Func2 (f: Char);
         VAR
           t     : Word;
           Hst2  : HistPtr;
         BEGIN
           Delete (Pstring, 1, 1);
           NEW (Hst2);
           Parse (Hst2, Pstring);
           CASE f OF
             '+' : FOR t := 1 TO Hmap.Tqty  DO
                     Hst^[t] := Hst^[t] + Hst2^[t];
             '-' : FOR t := 1 TO Hmap.Tqty  DO
                     Hst^[t] := Hst^[t] - Hst2^[t];
           END; {Case}
           DISPOSE (Hst2);
           Pstring := '';
         END;


       BEGIN {Parse}
         WHILE (Length (Pstring) <> 0) DO
           CASE Pstring[1] OF
             '('      : ParseBrackets;
             '['      : ParseHnum;
             'I', 'i', 'D', 'd', 'F', 'f', 'P', 'p', 'T', 't' :
                        Func1 (Pstring[1]);
             '+', '-' : Func2 (Pstring[1]);
             ' ' : Delete (Pstring, 1, 1);
           END; {While / Case}
       END; {Parse}
 {Routines and Data structures to Initialize Graphics System}


    CONST
       VGAoffset     = 64;
       EGAoffset     = 1;

    TYPE
      RGBrec = RECORD
                 Rd, Gr, Bl : Byte;
               END;
      RGBpalette = RECORD
                     Sz, Offset : Byte;
                     Clr        : ARRAY [0..255] OF RGBrec;
                   END;
      RGBpalPtr  = ^RGBpalette;

    CONST
      EGAdefault : PaletteType = ( Size:   16;
                                   Colors: ( $00, $01, $02, $03, $04, $05, $14, $07,
                                             $38, $39, $3A, $3B, $3C, $3D, $3E, $3F  )  );
      EGARainBow : PaletteType = ( Size:   16;
                                   Colors: ( $00, $01, $09, $0B, $13, $12, $16, $26,
                                             $24, $3C, $35, $05, $2D, $04, $3E, $3F  )  );

      VGAdefault :
             RECORD
               Sz, Offset : Byte;
               Clr        : ARRAY [0..15] OF RGBrec;
             END
                  = (  Sz:16;  Offset:0;
                       Clr : (   (Rd:$00; Gr:$00; Bl:$00),  {Black}
                                 (Rd:$00; Gr:$00; Bl:$2C),  {Blue}
                                 (Rd:$00; Gr:$2C; Bl:$00),  {Green}
                                 (Rd:$00; Gr:$2C; Bl:$2C),  {Cyan}
                                 (Rd:$2C; Gr:$00; Bl:$00),  {Red}
                                 (Rd:$2C; Gr:$00; Bl:$2C),  {Magenta}
                                 (Rd:$2C; Gr:$1C; Bl:$00),  {Brown}
                                 (Rd:$2C; Gr:$2C; Bl:$2C),  {Lt Grey}
                                 (Rd:$1C; Gr:$1C; Bl:$1C),  {Dark Grey}
                                 (Rd:$00; Gr:$00; Bl:$3C),  {Lt. Blue}
                                 (Rd:$00; Gr:$3C; Bl:$00),  {Lt. Green}
                                 (Rd:$00; Gr:$3C; Bl:$3C),  {Lt. Cyan}
                                 (Rd:$3C; Gr:$00; Bl:$00),  {Lt. Red}
                                 (Rd:$3C; Gr:$00; Bl:$3C),  {Lt. Magenta}
                                 (Rd:$3C; Gr:$3C; Bl:$00),  {Yellow}
                                 (Rd:$3C; Gr:$3C; Bl:$3C)   {Br White}     )  );

      VGARainbow16 :
            RECORD
              Sz, Offset : Byte;
              Clr        : ARRAY [0..12] OF RGBrec;
            END
                 = (  Sz:13;  Offset:EGAoffset;
                      Clr : (   (Rd:$00; Gr:$00; Bl:$24),
                                (Rd:$00; Gr:$00; Bl:$30),
                                (Rd:$00; Gr:$00; Bl:$3C),
                                (Rd:$00; Gr:$20; Bl:$30),
                                (Rd:$00; Gr:$24; Bl:$00),
                                (Rd:$00; Gr:$30; Bl:$00),
                                (Rd:$00; Gr:$3C; Bl:$00),
                                (Rd:$20; Gr:$30; Bl:$00),
                                (Rd:$20; Gr:$18; Bl:$00),
                                (Rd:$24; Gr:$00; Bl:$00),
                                (Rd:$30; Gr:$00; Bl:$00),
                                (Rd:$3C; Gr:$00; Bl:$00),
                                (Rd:$20; Gr:$00; Bl:$20)    )  );

      VGARainbow256:
            RECORD
              Sz, Offset : Byte;
              Clr        : ARRAY [0..55] OF RGBrec;
            END
                 = (  Sz:56;  Offset:VGAoffset;
                      Clr : (   (Rd:$00; Gr:$00; Bl:$20),
                                (Rd:$00; Gr:$00; Bl:$24),
                                (Rd:$00; Gr:$00; Bl:$28),
                                (Rd:$00; Gr:$00; Bl:$2C),
                                (Rd:$00; Gr:$00; Bl:$30),
                                (Rd:$00; Gr:$00; Bl:$34),
                                (Rd:$00; Gr:$00; Bl:$38),
                                (Rd:$00; Gr:$00; Bl:$3C),

                                (Rd:$00; Gr:$10; Bl:$2C),
                                (Rd:$00; Gr:$14; Bl:$28),
                                (Rd:$00; Gr:$18; Bl:$24),
                                (Rd:$00; Gr:$1C; Bl:$20),
                                (Rd:$00; Gr:$20; Bl:$1C),
                                (Rd:$00; Gr:$24; Bl:$18),
                                (Rd:$00; Gr:$28; Bl:$14),
                                (Rd:$00; Gr:$2C; Bl:$10),

                                (Rd:$00; Gr:$20; Bl:$00),
                                (Rd:$00; Gr:$24; Bl:$00),
                                (Rd:$00; Gr:$28; Bl:$00),
                                (Rd:$00; Gr:$2C; Bl:$00),
                                (Rd:$00; Gr:$30; Bl:$00),
                                (Rd:$00; Gr:$34; Bl:$00),
                                (Rd:$00; Gr:$38; Bl:$00),
                                (Rd:$00; Gr:$3C; Bl:$00),

                                (Rd:$10; Gr:$2C; Bl:$00),
                                (Rd:$14; Gr:$28; Bl:$00),
                                (Rd:$18; Gr:$24; Bl:$00),
                                (Rd:$1C; Gr:$20; Bl:$00),
                                (Rd:$20; Gr:$1C; Bl:$00),
                                (Rd:$24; Gr:$18; Bl:$00),
                                (Rd:$28; Gr:$14; Bl:$00),
                                (Rd:$2C; Gr:$10; Bl:$00),

                                (Rd:$20; Gr:$00; Bl:$00),
                                (Rd:$24; Gr:$00; Bl:$00),
                                (Rd:$28; Gr:$00; Bl:$00),
                                (Rd:$2C; Gr:$00; Bl:$00),
                                (Rd:$30; Gr:$00; Bl:$00),
                                (Rd:$34; Gr:$00; Bl:$00),
                                (Rd:$38; Gr:$00; Bl:$00),
                                (Rd:$3C; Gr:$00; Bl:$00),

                                (Rd:$38; Gr:$00; Bl:$04),
                                (Rd:$34; Gr:$00; Bl:$08),
                                (Rd:$30; Gr:$00; Bl:$0C),
                                (Rd:$2C; Gr:$00; Bl:$10),
                                (Rd:$28; Gr:$00; Bl:$14),
                                (Rd:$24; Gr:$00; Bl:$18),
                                (Rd:$20; Gr:$00; Bl:$1C),
                                (Rd:$1C; Gr:$00; Bl:$20),

                                (Rd:$20; Gr:$04; Bl:$20),
                                (Rd:$20; Gr:$08; Bl:$20),
                                (Rd:$20; Gr:$0C; Bl:$20),
                                (Rd:$20; Gr:$10; Bl:$20),
                                (Rd:$20; Gr:$14; Bl:$20),
                                (Rd:$20; Gr:$18; Bl:$20),
                                (Rd:$20; Gr:$1C; Bl:$20),
                                (Rd:$20; Gr:$20; Bl:$20)    )  );


     PROCEDURE SetAllRGB (Pal : RGBpalPtr);
       VAR
         Col : Integer;
       BEGIN
         WITH Pal^ DO
           FOR Col := Offset TO (Sz+Offset-1) DO
             BEGIN
               WITH Clr[Col-Offset] DO
                 SetRGBPalette (Col, Rd, Gr, Bl);
               SetPalette (Col,Col);
             END; {For}
         ColOffSet := VGAoffset;
       END; {SetAllRGB}

     PROCEDURE Ds_ResetPalette;
       BEGIN
         CASE GraphDriver OF
           IBM8514, VGA :
                     BEGIN
                       SetAllRGB (@VGAdefault);
                       ColOffSet := EGAoffset;
                     END; {VGA default Palette}
           EGA     : BEGIN
                       SetAllPalette (EGAdefault);
                       ColOffSet := EGAoffset;
                     END; {EGA}
         END; {Case GraphDriver}
       END; {Ds_ResetPalette}

     PROCEDURE Ds_SetPalette;
       BEGIN
         CASE GraphDriver OF
           IBM8514 : BEGIN
                       SetAllRGB (@VGARainBow256);
                       ColOffSet := VGAoffset;
                     END; {IBM8514 and VGA 256 colours}
           VGA     : BEGIN
                       SetAllRGB (@VGARainBow16);
                       ColOffSet := EGAoffset;
                     END; {16 colours - HiRes VGA}
           EGA     : BEGIN
                       SetAllPalette (EGARainBow);
                       ColOffSet := EGAoffset;
                     END; {EGA}
         END; {Case GraphDriver}
       END; {Ds_SetPalette}


     {$F+}
     FUNCTION DetectVGA256 : integer;
       {Detects VGA or MCGA video cards}
       VAR
         DetectedDriver : integer;
         SuggestedMode  : integer;
       BEGIN
         DetectGraph(DetectedDriver, SuggestedMode);
         IF ( ((DetectedDriver = VGA) OR (DetectedDriver = MCGA)) AND (Sets.VGA256) )
            THEN DetectVGA256 := 0    { Default video mode = 0 }
            ELSE DetectVGA256 := grError; { Couldn't detect hardware }
       END; {DetectVGA256}
     {$F-}

     PROCEDURE Ds_Init;
       VAR
         Hz_aspect, Vt_aspect : Word;
         AutoDetectPointer    : Pointer;
         Err                  : Integer;
       BEGIN
         CloseGraph;
         AutoDetectPointer := @DetectVGA256; {Point to detection routine}
         GraphDriver := InstallUserDriver('VGA256', AutoDetectPointer);
         GraphDriver := Detect;
         InitGraph   (GraphDriver, GraphMode, '');
         Err := GraphResult;
         Hpix    := GetMaxX + 1;
         Vpix    := GetMaxY + 1;
         MaxColours := GetMaxColor+1 - 2;  { Get the maximum allowable drawing color, subtract background and Black}
         GetAspectRatio  (Hz_aspect, Vt_aspect);
         Aspect  := Hz_aspect / Vt_aspect;
         ScrnAsp := Aspect * Hpix / Vpix;
         Vscale  := Vpix - 1;}
         Hscale  := TRUNC ( Vpix / Aspect - 1);}
         Vscale  := SnapWind.Sz[2]-1;
         Hscale  := SnapWind.Sz[1]-1;
         Hinset  := TRUNC (Hscale * 0.025);
         FontSz  := ROUND (2*Vpix/200);
         SetTextStyle (SmallFont, HorizDir, FontSz);
         CurGraphPg := 0;
       END; {Ds_Init}

   {Macro Routines in Display Resource}

     PROCEDURE Ds_ListLevels (Snp : Word);
       VAR
         Lev    : Word;
         LevStep: Word;
         S      : String;
         Vstep  : Real;
       BEGIN
         Ds_SetWindow (LegWind);
         Vstep := LegWind.Sz[2] / 3;
         ClearViewPort;
         SetTextStyle (SmallFont, HorizDir, FontSz);
         WITH SnapMap [Snp] DO
           BEGIN
             SetTextJustify (LeftText, CenterText);
             SetColor (Yellow);
             MoveTo ( Hinset, TRUNC(Vstep * (1.5/7))  );
             OutText ('  Snap Number ' + Strng (Snp,0) );
             SetColor (Yellow);
             MoveTo ( Hinset, TRUNC(Vstep * (3/7))  );
             OutText (' Variable = ' + VarName [SnapVar] );
             MoveTo ( Hinset, TRUNC(Vstep * (4/7))  );
             OutText (' Time     = ' + Strng (Time,$0300) );
             MoveTo ( Hinset, TRUNC(Vstep * (5/7))  );
             OutText (' MaxVal   = ' + Strng (MaxVal,$0300) );
             MoveTo ( Hinset, TRUNC(Vstep * (6/7))  );
             OutText (' MinVal   = ' + Strng (MinVal,$0300) );

             Lev := 1;
             LevStep := (Sets.QtyLevels-1) DIV 12 + 1;
             REPEAT
               MoveTo ( Hinset, TRUNC( Vstep * (1 + 2 * Lev / (Sets.QtyLevels+2)) )  );
               SetColor (LevCol [Lev]);
               IF ( (MaxVal<>0) AND (ABS(MaxVal) > ABS (MinVal)) )
                  THEN Str (Level[Lev]/MaxVal :14, S)
                  ELSE IF (MinVal <> 0)
                          THEN Str (Level[Lev]/MinVal :14, S)
                          ELSE Str (Level[Lev] :14, S);
               OutText (S);
               Lev := Lev + LevStep;
             UNTIL (Lev > Sets.QtyLevels);
           END; {With}
         ResetViewPort;
       END; {Ds_ListLevels}


     PROCEDURE Ds_DrawContour (P1, P2 : Point);
       VAR
         Px1, Px2 : Pixels;
       BEGIN
         Px1[1] := ROUND (Ds_PScale[x] * P1[X]);
         Px1[2] := ROUND (Ds_PScale[y] * P1[Y]);
         Px2[1] := ROUND (Ds_PScale[x] * P2[X]);
         Px2[2] := ROUND (Ds_PScale[y] * P2[Y]);
         Line (Px1[1], Px1[2], Px2[1], Px2[2]);
       END; {Ds_DrawContour}


     PROCEDURE Ds_CentreBar (Hz_st, Vt_st, Len, Ang: Real);

       PROCEDURE DoubleBar;
         CONST
           BarWidth = 0.5;
         VAR
           SinAng, CosAng : Real;
           Hz_Len, Vt_Len : Real;
           Cnr            : ARRAY [1..2] OF Pixels;
         BEGIN
           Len      := ABS(Len);
           CosAng   := COS(Ang);
           SinAng   := SIN(Ang);
           Hz_Len   := Len * CosAng;
           Vt_Len   := Len * SinAng;
           Cnr[1,1] := ROUND (Hz_st + Hz_Len/2 - (BarWidth * SinAng) );
           Cnr[1,2] := ROUND (Vt_st + Vt_Len/2 + (BarWidth * CosAng) );
           Cnr[2,1] := ROUND (Hz_st + Hz_Len/2 + (BarWidth * SinAng) );
           Cnr[2,2] := ROUND (Vt_st + Vt_Len/2 - (BarWidth * CosAng) );
           Line (Cnr[1,1], Cnr[1,2], ROUND (Cnr[1,1] - Hz_Len), ROUND (Cnr[1,2] - Vt_Len) );
           Line ( ROUND (Cnr[2,1] - Hz_Len), ROUND (Cnr[2,2] - Vt_Len), Cnr[2,1], Cnr[2,2]);
         END; {DoubleBar}

       PROCEDURE SingleBar;
         VAR
           Hz_Len, Vt_Len: Real;
         BEGIN
           Hz_Len := (Len * COS(Ang));
           Vt_Len := (Len * SIN(Ang));
           Hz_St := Hz_St + Hz_Len / 2;
           Vt_St := Vt_St + Vt_Len / 2;
           Line ( ROUND(Hz_St), ROUND(Vt_St), ROUND (Hz_St - Hz_Len), ROUND (Vt_St - Vt_Len) );
         END; {SingleBar}

       BEGIN {Ds_CentreBar}
         Ang := +Ang;     {Angles defined here as: +ve CCW}
         IF (Len < 0)
            THEN SingleBar
            ELSE DoubleBar;
       END; {Ds_CentreBar}

